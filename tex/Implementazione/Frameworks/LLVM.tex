\subsubsection{LLVM: Low Level Virtual Machine}
Ciò che accomuna Basalt, Rust, Zig e molti altri linguaggi moderni è l'adozione di LLVM 
come backend-framework. LLVM è un progetto open-source che si occupa di offrire una API 
per costruire manualmente rappresentazioni IR per le varie istruzioni di un programma, 
e di fornire un set di tool per ottimizzare e generare codice macchina a partire
da tali rappresentazioni IR. \\ 

In altri termini, LLVM si occupa di implementare le fasi di IR-optimization e 
codegen discusse in precedenza, essendo cross-platform, ovvero supportando 
varie CPU e varie architetture (x86, ARM, Web-Assembly, etc...). \\

LLVM è nato come libreria in C, ma sono stati successivamente scritti porting 
per C++ in primis, e a seguire per Rust ed Ada. \\

LLVM ha infine reso possibile la creazione di cling, un interprete C/C++ basato 
sul compilatore clang, il quale utilizza LLVM per effettuare JIT-compilation 
(compilazione "just in time", ovvero al volo) di codice C/C++. Tale 
strumento è tutt'ora di fondamentale importanza per la comunità scientifica, 
ed è in utilizzo presso il CERN.

\newpage

\subsubsection{Introduzione ad LL (LLVM-IR)}
LLVM, come già detto nel paragrafo precedente, è un progetto composto da un 
insieme di librerie, e da alcuni tool. Due di questi tool sono \texttt{lli} ed 
\texttt{llc}, rispettivamente un interprete IR e un compilatore IR. \\

Questi due strumenti possono essere usati per eseguire codice IR, fornito 
sotto forma di file di testo con estensione \texttt{.ll}. Analizzare la sintassi, 
e più in generale la semantica, di tale formato testuale renderà più facile comprendere 
l'utilizzo della API nei capitoli successivi. \\

Un simbolo globale deve essere preceduto dal carattere speciale "@", ad 
esempio la funzione che fa da entry-point per l'esecuzione del programma 
è definita come \texttt{@main}. \\ 

Per definire una funzione è necessario specificare il tipo di ritorno, il 
nome della funzione, e la lista dei parametri. Il corpo della funzione 
è racchiuso tra parentesi graffe. \\ 

\begin{lstlisting}[frame=single, language=LLVM]
define i32 @main() {
  entry:
    ret i32 0
}
\end{lstlisting}
\vspace{0.5cm}

Una funzione in LL è fatta da uno o più blocchi, ognuno dei quali è composto da 
una lista di istruzioni. Ogni blocco termina con un'istruzione di return o di salto. 
Nella funzione \texttt{@main} definita sopra, \texttt{entry} è una label, e definisce 
l'ingresso nell'omonimo blocco. Il blocco entry è un blocco speciale in quanto esso è 
il primo ad essere eseguito in ogni funzione. \\

L'istruzione \texttt{ret} effettua il return, e sancisce la fine del blocco 
corrente. Il valore restituito deve essere dello stesso tipo specificato nella 
firma della funzione, e tale tipo va esplicitamente specificato. \\

I nomi dei simboli, possono contenere spazi e/o caratteri speciali purchè
racchiusi tra doppi apici. Per effettuare un return da una funzione void 
servirà scrivere \texttt{ret void}. \\

\begin{lstlisting}[frame=single]
define void %"example void function"() {
  entry:
    ret void
}
\end{lstlisting}
\vspace{0.5cm}

L'utilizzo di "\%" in luogo di "@" identifica un simbolo come locale invece che globale, pertanto 
esso non sarà visibile all'esterno del file \texttt{.ll} in cui esso è definito.

\newpage

\subsubsection{Implementazione di strutture dati in LL}
È possibile definire delle struct in LL, le quali sono simboli come le funzioni e possono essere 
globali o locali. Di seguito è riportato un esempio di definizione di due struct locali, che rappresentano 
rispettivamente uno stack (struttura dati) ed un suo nodo. \\

\vspace{0.5cm}
\begin{lstlisting}[frame=single]
%Stack = type { 
    %Node*, 
    i64 
}

%Node = type { 
    %Node*, 
    i32 
}
\end{lstlisting}
\vspace{0.5cm}

Volendo mostrare solo un esempio di come è possibile usare le struct definite sopra,
si riporta la definizione di una funzione che stampa tutti gli elementi di uno stack. \\

Nel seguente frammento di codice \texttt{.ll}, si può notare che per chiamare una funzione, 
si utilizza l'istruzione \texttt{call}, la quale richiede l'esplicita specificazione del tipo
di ritorno della funzione chiamata. L'istruzione \texttt{br} è una istruzione di salto. \\

\vspace{0.5cm}
\begin{lstlisting}[frame=single]
define void @printStack(%Stack* %stack) {
  entry:
    %cursorPtr = call %Node* @getHead(%Stack* %stack)
    br label %loopCondition

  loopCondition:
    %cursor = load %Node*, %Node** %cursorPtr    
    %condition = icmp ne %Node* %cursor, null
    br i1 %condition, label %loopBody, label %loopExit

  loopBody:
    %currentNumberPtr = call i32* @getNumber(%Node* %cursor)
    %currentNumber = load i32, i32* %currentNumberPtr
    call void @printInt(i32 %currentNumber) 
    %currentNextPtr = call %Node* @getNext(%Node* %cursor)
    %currentNext = load %Node*, %Node** %currentNextPtr
    store %Node* %currentNext, %Node** %cursorPtr
    br label %loopCondition

  loopExit:
    ret void
}
\end{lstlisting}
\vspace{0.5cm}

\newpage

\subsubsection{Utilizzo della memoria in LL}
In LL, la memoria è gestita in modo drasticamente diverso rispetto 
a come avviene nei linguaggi di programmazione di uso comune. \\ 

Nei linguaggi di programmazione tipici una variabile è associata ad un indirizzo 
di memoria, ed è possibile assegnare valori a tale variabile riferendosi ad essa con il suo nome. Quando 
servirà leggere il valore di tale variabile, sarà sufficiente, ancora una volta, riferirsi ad essa 
con il suo nome. \\

In LL ciò non avviene, in quanto le variabili non hanno un vero e proprio indirizzo di memoria, 
e sono invece solo dei simboli. Si consideri ad esempio il seguente frammento di codice Basalt, 
ed alla sua traduzione in LL:

\vspace{0.5cm}
\begin{lstlisting}[frame=single]
var number : Int = 42;
console::println(number);
\end{lstlisting}

\begin{lstlisting}[frame=single]
example_block:
  %numberAddress = alloca i64
  store i64 42, i64* %numberAddress
  %numberValue = load i64, i64* %numberAddress
  call void @"console::println<Int>"(i64 %numberValue)
\end{lstlisting}
\vspace{0.5cm}

Si noti come la variabile \texttt{number} sia stata tradotta come la \texttt{numberAddress} e \texttt{numberValue}.
La variabile \texttt{numberAddress} è un puntatore ad una locazione di memoria, e la variabile \texttt{numberValue}
è il valore numerico contenuto in tale area di memoria. \\

Nè \texttt{numberValue} nè \texttt{numberAddress} in 
questo caso hanno dei veri e propri indirizzi di memoria propri. Essi sono solo dei simboli 
a cui sono associati dei valori. \\

La gestione della memoria di LL può sembrare controintuitiva al programmatore medio, ed è proprio per questo 
che anche se LL è un vero e proprio linguaggio, esso non è considerato veramente utilizzabile. Si è infatti abituati
a ragionare in termini di variabili, intese come coppie indirizzo/valore, ed un approccio simile è facilmente 
classificabile come innaturale. \\

È bene ricordarsi però che i calcolatori utilizzano internamente una rappresentazione 
analoga a quella proposta da LL, ed è proprio per questo che LL è facilmente ed efficientemente traducibile 
in linguaggio macchina nativo per molteplici architetture. \\

\newpage